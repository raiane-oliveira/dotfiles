#!/bin/bash

# Script para executar opencode com anima√ß√£o de loading e salvamento estruturado
# Uso: ./ask_ai.sh [argumentos para opencode]

# Cores para melhor visualiza√ß√£o
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Diret√≥rio de sa√≠da
FULL_OUTPUT_DIR="$HOME/Documents/ai/responses"
REDUCED_OUTPUT_DIR="~/Documents/ai/responses"
TEMP_FILE="/tmp/opencode_output_$$"
PID_FILE="/tmp/opencode_pid_$$"

# Fun√ß√£o para limpar arquivos tempor√°rios
cleanup() {
  rm -f "$TEMP_FILE" "$PID_FILE"
  # Para a anima√ß√£o se ainda estiver rodando
  if [[ -n "$LOADING_PID" ]]; then
    kill $LOADING_PID 2>/dev/null
  fi
}

# Trap para limpar em caso de interrup√ß√£o
trap cleanup EXIT INT TERM

# Fun√ß√£o de anima√ß√£o de loading
show_loading() {
  local chars="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
  local delay=0.1

  while true; do
    for ((i = 0; i < ${#chars}; i++)); do
      printf "\r${YELLOW}${chars:$i:1} Executando opencode...${NC}"
      sleep $delay
    done
  done
}

# Fun√ß√£o para criar estrutura de diret√≥rios
create_output_structure() {
  if [[ ! -d "$FULL_OUTPUT_DIR" ]]; then
    mkdir -p "$FULL_OUTPUT_DIR"
    echo -e "${GREEN}‚úì Diret√≥rio criado: $FULL_OUTPUT_DIR${NC}"
  fi
}

# Fun√ß√£o para gerar nome do arquivo baseado na pergunta do usu√°rio
generate_filename() {
  local question="$*"
  local timestamp=$(date '+%Y%m%d_%H%M')

  # Sanitiza a pergunta do usu√°rio
  local sanitized=$(echo "$question" |
    tr '[:upper:]' '[:lower:]' |
    sed 's/[^a-z0-9 ]//g' |
    sed 's/[[:space:]]\+/-/g' |
    sed 's/^-\+\|-\+$//g' |
    head -c 50)

  # Se a pergunta sanitizada ficar vazia, usa um nome padr√£o
  if [[ -z "$sanitized" ]]; then
    sanitized="pergunta"
  fi

  echo "${sanitized}-${timestamp}.md"
}

# Fun√ß√£o para executar opencode em background
execute_opencode() {
  local args="$*"

  # Executa o comando e salva o output
  {
    echo $$ >"$PID_FILE"
    opencode run --model github-copilot/gpt-5-mini "$@" 2>&1
  } >"$TEMP_FILE" &

  # Salva o PID do processo opencode
  local opencode_pid=$!

  # Inicia anima√ß√£o de loading
  show_loading &
  LOADING_PID=$!

  # Espera o comando terminar
  wait $opencode_pid
  local exit_code=$?

  # Para a anima√ß√£o
  kill $LOADING_PID 2>/dev/null
  LOADING_PID=""

  # Limpa a linha da anima√ß√£o
  printf "\r"

  return $exit_code
}

# Fun√ß√£o para salvar output estruturado
save_structured_output() {
  local filename="$1"
  local args="$2"
  local exit_code="$3"
  local filepath="$FULL_OUTPUT_DIR/$filename"
  local reducedFilePath="$REDUCED_OUTPUT_DIR/$filename"

  # Cria arquivo estruturado em formato markdown
  cat >"$filepath" <<EOF
> Pergunta: $args

$(cat "$TEMP_FILE")

---

## Execution Details

- **Exit Code:** $exit_code
- **User:** $(whoami)
- **Working Directory:** \`$(pwd)\`
- **Lines:** $(wc -l <"$TEMP_FILE") lines
- **Output Size:** $(wc -c <"$TEMP_FILE") bytes

---

*Generated by ask_ai.sh on $(date '+%Y-%m-%d %H:%M:%S')*
EOF

  echo -e "${GREEN}‚úì Output salvo em: $reducedFilePath${NC}"
}

# Fun√ß√£o para exibir estat√≠sticas
show_stats() {
  local filepath="$1"
  local lines=$(wc -l <"$TEMP_FILE")
  local chars=$(wc -c <"$TEMP_FILE")
  local words=$(wc -w <"$TEMP_FILE")

  echo -e "${BLUE}üìä Estat√≠sticas:${NC}"
  echo -e "   Linhas: $lines"
  echo -e "   Palavras: $words"
  echo -e "   Caracteres: $chars"
}

# Fun√ß√£o principal
main() {
  # Verifica se h√° argumentos
  if [[ $# -eq 0 ]]; then
    echo -e "${RED}‚ùå Erro: Nenhum argumento fornecido${NC}"
    echo -e "${YELLOW}Uso: $0 [argumentos para opencode]${NC}"
    echo -e "${YELLOW}Exemplo: $0 \"Crie uma fun√ß√£o em Python para calcular fibonacci\"${NC}"
    exit 1
  fi

  echo -e "${BLUE} Iniciando execu√ß√£o do OpenCode...${NC}"

  # Cria estrutura de diret√≥rios
  create_output_structure

  # Gera nome do arquivo
  local filename=$(generate_filename "$@")

  # Executa opencode
  execute_opencode "$@"
  local exit_code=$?

  # Verifica se houve output
  if [[ ! -f "$TEMP_FILE" ]] || [[ ! -s "$TEMP_FILE" ]]; then
    echo -e "${RED}‚ùå Erro: Nenhum output foi gerado${NC}"
    exit 1
  fi

  # Mostra status da execu√ß√£o
  if [[ $exit_code -ne 0 ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Comando finalizado com c√≥digo de sa√≠da: $exit_code${NC}"
  fi

  echo "=================================================================================="

  # Exibe o output na tela
  cat "$TEMP_FILE"

  echo -e "\n=================================================================================="

  # Salva output estruturado
  save_structured_output "$filename" "$*" "$exit_code"

  # Mostra estat√≠sticas
  show_stats "$FULL_OUTPUT_DIR/$filename"
}

# Executa fun√ß√£o principal
main "$@"
